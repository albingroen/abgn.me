---
title: "One Year of Trying To Be an AI Optimist"
date: "2025-12-19"
author: "Albin Groen"
excerpt: "On new years eve last year I told myself I wanted to really adopt AI. Let's talk about it."
image: https://res.cloudinary.com/albin-groen/image/upload/v1766166157/og_z7t7fq.png
---

One year ago I set a New Year's resolution for myself to be an AI optimist for 2025. Before this, I had been a bit of a skeptic, you might say, and I still am in my core. But I thought it would be an interesting perspective to go through 2025 with.

## The beginning

---

In the beginning of the year I went out hard. I wanted to use AI in every single part of my life. Personal and work. This was fun, and there were certainly some good use cases. For example, taking a photo of a whiteboard after a meeting, uploading to my Mac's Raycast chat instance, and asking an LLM to OCR what was on there. Cool, not groundbreaking.

## Developer tools

---

At this point, I was still a heavy terminal and Neovim user. This is how I'd been working for the last 6 years or so. And I loved it. I created this really productive environment where I could fly through files. Going from idea to code has never really been the hard part for me. I think learning Vim and Neovim was one of the best things I've done for my career for the first 6 years. I would see colleagues of mine slowly click through an IDE with their mouse, while I would already have a draft PR out.

### Trying out AI dev-tools

---

As the year went by, I started hearing more and more about Cursor. I tried it. Didn't like it, went back to Neovim. Then I heard more and more about Zed. Tried it, _really liked_ it, but then went back to Neovim. I used some AI plugins for Neovim, like Copilot and gp.nvim, and it worked quite well.

Then agentic editing started to surface. It was quite bad in the beginning. But after the summer of 2025, things really started accelerating. I gave Cursor another shot, and with the release of Composer 1, I found myself not going back to Neovim. When I did go back, I just cringed at the incredible latency and performance of Copilot. And not having gp.nvim actually implement the changes it suggested, but just displaying them made me realize the jump ahead Cursor had created for itself.

Composer 1 and the agents panel is absolutely crazy. There's so much power here, and it can write a _lot_ of code. Some pretty good, and some less. I really think it's great. But it's such a double edged sword.

### Writing is better than reading

---

I think this is a term you've probably heard in other contexts in your life. If you can't remember, go back to your school days. Someone near you probably mentioned that when you write something down, you remember it better. I think this is interesting. Having an agent write your code and then you reviewing (i.e., reading) _works_. But the problem is that you won't build a mental model or deep understanding of the code.

#### Does it matter?

---

On one hand I deeply believe in the previous paragraph. And, I want to go back to pure Neovim and write every single line of code by hand. Except boilerplate of course (this is something we all have to agree on is better with LLMs). But then I jump a few years ahead in my mind, and think about where the industry is in 10, 15, or even 20 years. I'm just 26 years old. I joined my first startup at 18 and I've been building web and mobile apps at all types of companies ever since. But where are we in 20 years? Will code even matter, or will English just be the next elevator level in the skyscraper of language abstractions?

### Knowing your code matters

---

Knowing how your codebase works on a deeper level is really valuable. If a customer comes to you with a bug, you can't blame the LLM.

> You know, uuhmm... I didn't actually write that code. But I'll check with the Claude.

How would you feel if a service provider you use in your company would answer something like that to a bug you report? Sure, they won't answer like that. But they'll think it. How does that feel to you? Probably not great. It doesn't bring a huge sense of trust in that company.

I **know** there's real value in deeply understanding the code you write. Even if it's boring code at times, it's valuable. Taking ownership of what you ship to customers. After all, "customers" are just simple peasants like you and me. And I fucking hate when Netflix won't load half of the shows on my Samsung smart TV. You have to ask yourself what you expect from the products and services you use. And then apply those expectations to the products you build.

### The future

---

So, it seems like things are only going in one direction: abstractions. English to code. It kinda works. You can ship a ton. And your boss is probably happy because your team is delivering more features. Your users? Who knows. Maybe they're happy. But honestly, as a user, I don't give a hell if Netflix ships a bunch of new features. I just care about their core. If their new fancy features are all half-baked, laggy pieces of crap, I'll watch something on Apple TV instead.

Another thing that's worth reflecting on is that even though it might _seem_ like everything is going in one direction in the insutry. **It doesn't mean we have to go that route**. It's not like there's just one final master goal to all of this. These are just private companies who want to sell us their services. And, you might not believe it... But we don't have to buy it.
